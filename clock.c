//ELD002 Group Project: Cybots
//Chronos System Software
//
//FILE DESCRIPTION
//clock.c
//Contains functions for timers.
//
//CONTAINS FUNCTIONS
//clock_initiate
//clock_start
//Timer0_A0_ISR
//clock_decrement
//beep_decrement
//change_period
//stop_mode
//
//WRITTEN BY
//Chris Elmer

//INCLUDES
#include "main.h"	//Project header

// Global Variable section
unsigned volatile  time_elapsed[2];	//Time elapsed counter
unsigned volatile counts_remaining;	//Counts remaining counter
unsigned volatile beep_enable;	//Toggles audible feedback
unsigned volatile beep_timer;	//Times beep in STOP_MODE
unsigned volatile quad_tick;	//Keeps track of 1/4 seconds
unsigned volatile clock_speed;	//Controls clock speed 1 is slow 4 is fast
unsigned volatile accel_counter;	//Stops accelerometer being read within 10 secs of last trigger

//FUNCTIONS
//Clock Initiate
void clock_initiate (void)
{
	extern unsigned volatile time_elapsed[2];
	extern unsigned volatile counts_remaining;
	extern unsigned volatile beep_timer;
	extern unsigned volatile quad_tick;
	extern unsigned volatile clock_speed;
	extern unsigned volatile accel_counter;
	extern unsigned volatile beep_enable;

	// Set interrupt frequency to 1Hz
	TA0CCR0   = 8192;

	// Enable timer interrupt    
	TA0CCTL0 |= CCIE;

	// Clear and start timer now
	// Continuous mode: Count to 0xFFFF and restart from 0 again - 1sec timing will be generated by ISR
	TA0CTL   |= TASSEL0 + MC1 + TACLR;

	//Set clock values.
	time_elapsed[0] = 10;
	time_elapsed[1] = 00;
	counts_remaining = 600;
	beep_timer = 60;
	quad_tick = 1;
	clock_speed = 1;
	accel_counter = 0;
	beep_enable = 0;
}

//Clock start
void clock_start (void)
{
	// Start Timer0 in continuous mode
	TA0CTL |= MC_2;
}


//Timer 0 ISR
#pragma vector = TIMER0_A0_VECTOR
__interrupt void TIMER0_A0_ISR(void)
{
	extern unsigned volatile time_elapsed[2];
	extern unsigned volatile counts_remaining;
	extern unsigned volatile beep_enable;
	extern unsigned volatile beep_timer;
	extern volatile unsigned programme_mode;
	extern unsigned volatile quad_tick;
	extern unsigned volatile clock_speed;
	extern unsigned volatile accel_counter;

	// Disable IE
	TA0CCTL0 &= ~CCIE;
	// Reset IRQ flag
	TA0CCTL0 &= ~CCIFG;
	// Add 1 sec to TACCR0 register (IRQ will be asserted at 0x7FFF and 0xFFFF = 1/4 sec intervals)
	TA0CCR0 += 8192;
	// Enable IE
	TA0CCTL0 |= CCIE;

	//Clock
	if (programme_mode == TIMING_MODE)
	{
		clock_decrement ();
		check_accel();
		flash_heart();
	}
	//Buzzer at stop
	if (programme_mode == STOP_MODE)
		beep_decrement();

	//Flash Beep
	if (beep_enable == 1)
		f_beep();
}

//Clock Decrement
void clock_decrement (void)
{
	extern unsigned volatile time_elapsed[2];
	extern unsigned volatile counts_remaining;
	extern volatile unsigned programme_mode;
	extern unsigned volatile quad_tick;
	extern unsigned volatile clock_speed;

	//Time elapsed timer.
	if ((quad_tick / 4) == 1)
	{
		if (time_elapsed[1] == 0)
		{
			time_elapsed[1] = 59;
			if (time_elapsed[0] == 0) //Time Up
				stop_mode();
			else
				--time_elapsed[0];
		}
		else
			--time_elapsed[1];
	}

	//Counts remaining timer
	if ((quad_tick / clock_speed) == 1)
	{
		if (counts_remaining == 0)
			stop_mode();
		else
			--counts_remaining;
	}

	//1/4 second timer
	if (quad_tick == 4)
		quad_tick = 1;
	else
		++ quad_tick;
}

//Beep Decrement
//Controls 1 min beep at stop
void beep_decrement (void)
{
	extern unsigned volatile beep_timer;
	extern unsigned volatile beep_enable;
	if (beep_timer == 240)
	{
		if (beep_enable == 1)
		{
			start_buzzer(10, 1, 1);
		}
	}
	else if (beep_timer == 0)
	{
		if (beep_enable == 1)
		{
			stop_buzzer();
		}
	}
	else
		--beep_timer;
}

//Change period
//Input 1 to speed up, 0 to slow down
void change_period (unsigned change)
{
	extern unsigned volatile clock_speed;
	extern unsigned volatile accel_counter;

	if (change == 1)	//Speed up
	{
		if ((clock_speed == 1) | (clock_speed == 2))
		{
			clock_speed = clock_speed * 2;	//Speed Up
			accel_counter = 40;	//Don't check accelerometer for 10 seconds.
		}
		else if (clock_speed == 4)	//Stop
		{
			stop_mode();
		}
	}
	else if (change == 0)	//Slow down
	{
		if ((clock_speed == 2) | (clock_speed == 4))
			clock_speed = clock_speed / 2;
	}

	if (clock_speed == 1)
		display_symbol(LCD_ICON_STOPWATCH, SEG_OFF);
	if ((clock_speed == 2) | (clock_speed == 4))
		display_symbol(LCD_ICON_STOPWATCH, SEG_ON);
}

//Stop mode
//Stops clock and changes mode
void stop_mode (void)
{
	extern volatile unsigned programme_mode;
	extern volatile unsigned counts_remaining;
	extern volatile unsigned time_elapsed[2];

	programme_mode = STOP_MODE;
	as_stop();
	counts_remaining = 000;
	time_elapsed[1] = 00;
	time_elapsed[0] = 00;
}
